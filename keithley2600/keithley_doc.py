# -*- coding: utf-8 -*-
#
# Copyright Â© keithley2600 Project Contributors
# Licensed under the terms of the MIT License
# (see keithley2600/__init__.py for details)


# Warning: PROPERTIES, CONSTANTS, FUNCTIONS and CLASSES must be mutually
# exclusive. A string used for a PROPERTY cannot be used to create a class
# later, when the property already exists (and vice versa).

"""
Submodule listing accepted Keithley TSP commands.
"""

import itertools


__all__ = [
    "CONSTANTS",
    "FUNCTIONS",
    "CLASSES",
    "PROPERTIES",
    "PROPERTY_LISTS",
    "ALL_CMDS",
]

PROPERTIES = (
    "enable",
    "appendmode",
    "basetimestamp",
    "cachemode",
    "capacity",
    "collectsourcevalues",
    "collecttimestamps",
    "fillcount",
    "fillmode",
    "measurefunctions",
    "measureranges",
    "n",
    "readings",
    "sourcefunctions",
    "sourceoutputstates",
    "sourceranges",
    "sourcevalues",
    "statuses",
    "timestampresolution",
    "timestamps",
    "count",
    "mode",
    "overrun",
    "pulsewidth",
    "stimulus",
    "writeprotect",
    "locallockout",
    "numpad",
    "screen",
    "digits",
    "func",
    "func",
    "overrun",
    "count",
    "count",
    "enable",
    "overwritemethod",
    "asciiprecision",
    "byteorder",
    "data",
    "address",
    "autoconnect",
    "address[N]",
    "domain",
    "dynamic",
    "hostname",
    "verify",
    "duplex",
    "gateway",
    "ipaddress",
    "method",
    "speed",
    "subnetmask",
    "linktimeout",
    "lxidomain",
    "nagle",
    "address[N]",
    "name",
    "duplex",
    "gateway",
    "ipaddress",
    "macaddress",
    "dst",
    "rawsocket",
    "telnet",
    "vxi11",
    "speed",
    "subnetmask",
    "timedwait",
    "ipaddress",
    "mode",
    "overrun",
    "protocol",
    "pseudostate",
    "stimulus",
    "autolinefreq",
    "description",
    "linefreq",
    "model",
    "password",
    "passwordmode",
    "prompts",
    "prompts4882",
    "revision",
    "serialno",
    "showerrors",
    "anonymous",
    "autorun",
    "name",
    "baud",
    "databits",
    "flowcontrol",
    "parity",
    "poweron",
    "adjustdate",
    "date",
    "due",
    "password",
    "polarity",
    "state",
    "speed",
    "threshold",
    "analogfilter",
    "autorangev",
    "autorangei",
    "autozero",
    "count",
    "delay",
    "delayfactor",
    "count",
    "enable",
    "type",
    "highcrangedelayfactor",
    "interval",
    "lowrangev",
    "lowrangei",
    "nplc",
    "rangev",
    "rangei",
    "enablev",
    "enablei",
    "enabler",
    "enablep",
    "levelv",
    "leveli",
    "levelr",
    "levelp",
    "sense",
    "autorangev",
    "autorangei",
    "compliance",
    "delay",
    "func",
    "highc",
    "limitv",
    "limiti",
    "lowrangev",
    "lowrangei",
    "offfunc",
    "offlimitv",
    "offlimiti",
    "offmode",
    "output",
    "outputenableaction",
    "settling",
    "sink",
    "count",
    "stimulus",
    "autoclear",
    "count",
    "action",
    "stimulus",
    "action",
    "action",
    "stimulus",
    "action",
    "stimulus",
    "condition",
    "node_enable",
    "node_event",
    "request_enable",
    "request_event",
    "orenable",
    "overrun",
    "stimulus",
    "count",
    "delay",
    "delaylist",
    "overrun",
    "passthrough",
    "stimulus",
    "group",
    "master",
    "state",
    "mode",
    "overrun",
    "pulsewidth",
    "stimulus",
    "writeprotect",
    "timeout",
    "abortonconnect",
    "condition",
    "enable",
    "event",
    "ntr",
    "ptr",
)

CLASSES = (
    "arm",
    "beeper",
    "bit",
    "blender",
    "buffer",
    "buffer_available",
    "cal",
    "calibrating",
    "calibration",
    "config",
    "contact",
    "current_limit",
    "dataqueue",
    "digio",
    "display",
    "dns",
    "endpulse",
    "endsweep",
    "errorqueue",
    "eventlog",
    "factory",
    "filter",
    "format",
    "fs",
    "gpib",
    "instrument",
    "io",
    "lan",
    "limit",
    "loadmenu",
    "localnode",
    "measure",
    "measurement",
    "measuring",
    "node",
    "nvbuffer1",
    "nvbuffer2",
    "operation",
    "os",
    "over_temperature",
    "port",
    "questionable",
    "reading_overflow",
    "rel",
    "remote",
    "script",
    "serial",
    "setup",
    "smua",
    "smub",
    "source",
    "standard",
    "status",
    "sweeping",
    "system",
    "system2",
    "system3",
    "system4",
    "system5",
    "timer",
    "trigger",
    "trigger_blender",
    "trigger_overrrun",
    "trigger_overrun",
    "trigger_timer",
    "tsp",
    "tsplink",
    "tspnet",
    "unstable_output",
    "user",
    "userstring",
    "voltage_limit",
)

# missing commands:
# 'lan.trigger[N].connected_': conflicts with `connected` attribute of Keithley2600Base
# 'io.output', # XXX: conflicts with PROPERTY smuX.source.output


_ALL_CMDS_WITH_PLACEHOLDERS = (
    "ConfigPulseIMeasureV()",
    "ConfigPulseIMeasureVSweepLin()",
    "ConfigPulseIMeasureVSweepLog()",
    "ConfigPulseVMeasureI()",
    "ConfigPulseVMeasureISweepLin()",
    "ConfigPulseVMeasureISweepLog()",
    "InitiatePulseTest()",
    "InitiatePulseTestDual()",
    "PulseIMeasureV()",
    "PulseVMeasureI()",
    "QueryPulseConfig()",
    "SweepILinMeasureV()",
    "SweepIListMeasureV()",
    "SweepILogMeasureV()",
    "SweepVLinMeasureI()",
    "SweepVListMeasureI()",
    "SweepVLogMeasureI()",
    "beeper.OFF",
    "beeper.ON",
    "beeper.beep()",
    "beeper.enable",
    "bit.bitand()",
    "bit.bitor()",
    "bit.bitxor()",
    "bit.clear()",
    "bit.get()",
    "bit.getfield()",
    "bit.set()",
    "bit.setfield()",
    "bit.test()",
    "bit.toggle()",
    "dataqueue.CAPACITY",
    "dataqueue.add()",
    "dataqueue.clear()",
    "dataqueue.count",
    "dataqueue.next()",
    "delay()",
    "digio.readbit()",
    "digio.readport()",
    "digio.trigger[N].EVENT_ID",
    "digio.trigger[N].assert()",
    "digio.trigger[N].clear()",
    "digio.trigger[N].mode",
    "digio.trigger[N].overrun",
    "digio.trigger[N].pulsewidth",
    "digio.trigger[N].release()",
    "digio.trigger[N].reset()",
    "digio.trigger[N].stimulus",
    "digio.trigger[N].wait()",
    "digio.writebit()",
    "digio.writeport()",
    "digio.writeprotect",
    "display.DIGITS_4_5",
    "display.DIGITS_5_5",
    "display.DIGITS_6_5",
    "display.KEY_AUTO",
    "display.KEY_CONFIG",
    "display.KEY_DIGITSA",
    "display.KEY_DIGITSB",
    "display.KEY_DISPLAY",
    "display.KEY_ENTER",
    "display.KEY_EXIT",
    "display.KEY_FILTERA",
    "display.KEY_FILTERB",
    "display.KEY_LEFT",
    "display.KEY_LIMITA",
    "display.KEY_LIMITB",
    "display.KEY_LOAD",
    "display.KEY_MEASA",
    "display.KEY_MEASB",
    "display.KEY_MENU",
    "display.KEY_MODEA",
    "display.KEY_MODEB",
    "display.KEY_NONE",
    "display.KEY_OUTPUTA",
    "display.KEY_OUTPUTB",
    "display.KEY_RANGEDOWN",
    "display.KEY_RANGEUP",
    "display.KEY_RECALL",
    "display.KEY_RELA",
    "display.KEY_RELB",
    "display.KEY_RIGHT",
    "display.KEY_RUN",
    "display.KEY_SPEEDA",
    "display.KEY_SPEEDB",
    "display.KEY_SRCA",
    "display.KEY_SRCB",
    "display.KEY_STORE",
    "display.KEY_TRIG",
    "display.LIMIT_IV",
    "display.LIMIT_P",
    "display.LOCK",
    "display.MEASURE_DCAMPS",
    "display.MEASURE_DCVOLTS",
    "display.MEASURE_OHMS",
    "display.MEASURE_WATTS",
    "display.SMUA",
    "display.SMUA_SMUB",
    "display.SMUB",
    "display.UNLOCK",
    "display.USER",
    "display.WHEEL_ENTER",
    "display.WHEEL_LEFT",
    "display.WHEEL_RIGHT",
    "display.clear()",
    "display.getannunciators()",
    "display.getcursor()",
    "display.getlastkey()",
    "display.gettext()",
    "display.inputvalue()",
    "display.loadmenu.add()",
    "display.loadmenu.catalog()",
    "display.loadmenu.delete()",
    "display.locallockout",
    "display.menu()",
    "display.numpad",
    "display.prompt()",
    "display.screen",
    "display.sendkey()",
    "display.setcursor()",
    "display.settext()",
    "display.smu{smu_name}.digits",
    "display.smu{smu_name}.limit.func",
    "display.smu{smu_name}.measure.func",
    "display.trigger.EVENT_ID",
    "display.trigger.clear()",
    "display.trigger.overrun",
    "display.trigger.wait()",
    "display.waitkey()",
    "errorqueue.clear()",
    "errorqueue.count",
    "errorqueue.next()",
    "eventlog.DISABLE",
    "eventlog.DISCARD_NEWEST",
    "eventlog.DISCARD_OLDEST",
    "eventlog.ENABLE",
    "eventlog.all()",
    "eventlog.clear()",
    "eventlog.count",
    "eventlog.enable",
    "eventlog.next()",
    "eventlog.overwritemethod",
    "exit()",
    "format.BIGENDIAN",
    "format.DREAL",
    "format.LITTLEENDIAN",
    "format.NETWORK",
    "format.NORMAL",
    "format.REAL",
    "format.REAL32",
    "format.REAL64",
    "format.SREAL",
    "format.SWAPPED",
    "format.asciiprecision",
    "format.byteorder",
    "format.data",
    "fs.chdir()",
    "fs.cwd()",
    "fs.is_dir()",
    "fs.is_file()",
    "fs.mkdir()",
    "fs.readdir()",
    "fs.rmdir()",
    "gettimezone()",
    "gm_isweep()",
    "gm_vsweep()",
    "gpib.address",
    "i_leakage_measure()",
    "i_leakage_threshold()",
    "io.close()",
    "io.flush()",
    "io.input()",
    "io.open()",
    "io.read()",
    "io.type()",
    "io.write()",
    "lan.AUTO",
    "lan.DISABLE",
    "lan.ENABLE",
    "lan.FULL",
    "lan.HALF",
    "lan.MANUAL",
    "lan.TRIG_EITHER",
    "lan.TRIG_FALLING",
    "lan.TRIG_RISING",
    "lan.TRIG_RISINGA",
    "lan.TRIG_RISINGM",
    "lan.TRIG_SYNCHRONOUS",
    "lan.TRIG_SYNCHRONOUSA",
    "lan.TRIG_SYNCHRONOUSM",
    "lan.applysettings()",
    "lan.autoconnect",
    "lan.config.dns.address[N]",
    "lan.config.dns.domain",
    "lan.config.dns.dynamic",
    "lan.config.dns.hostname",
    "lan.config.dns.verify",
    "lan.config.duplex",
    "lan.config.gateway",
    "lan.config.ipaddress",
    "lan.config.method",
    "lan.config.speed",
    "lan.config.subnetmask",
    "lan.linktimeout",
    "lan.lxidomain",
    "lan.nagle",
    "lan.reset()",
    "lan.restoredefaults()",
    "lan.status.dns.address[N]",
    "lan.status.dns.name",
    "lan.status.duplex",
    "lan.status.gateway",
    "lan.status.ipaddress",
    "lan.status.macaddress",
    "lan.status.port.dst",
    "lan.status.port.rawsocket",
    "lan.status.port.telnet",
    "lan.status.port.vxi11",
    "lan.status.speed",
    "lan.status.subnetmask",
    "lan.timedwait",
    "lan.trigger[N].EVENT_ID",
    "lan.trigger[N].assert()",
    "lan.trigger[N].clear()",
    "lan.trigger[N].connect()",
    "lan.trigger[N].connected",
    "lan.trigger[N].disconnect()",
    "lan.trigger[N].ipaddress",
    "lan.trigger[N].mode",
    "lan.trigger[N].overrun",
    "lan.trigger[N].protocol",
    "lan.trigger[N].pseudostate",
    "lan.trigger[N].stimulus",
    "lan.trigger[N].wait()",
    "localnode.PASSWORD_ALL",
    "localnode.PASSWORD_LAN",
    "localnode.PASSWORD_NONE",
    "localnode.PASSWORD_WEB",
    "localnode.autolinefreq",
    "localnode.description",
    "localnode.linefreq",
    "localnode.model",
    "localnode.password",
    "localnode.passwordmode",
    "localnode.prompts",
    "localnode.prompts4882",
    "localnode.reset()",
    "localnode.revision",
    "localnode.serialno",
    "localnode.showerrors",
    "makegetter()",
    "makesetter()",
    "meminfo()",
    "node[N].execute()",
    "node[N].getglobal()",
    "node[N].setglobal()",
    "nvbuffer{number}.appendmode",
    "nvbuffer{number}.basetimestamp",
    "nvbuffer{number}.cachemode",
    "nvbuffer{number}.capacity",
    "nvbuffer{number}.clear()",
    "nvbuffer{number}.clearcache()",
    "nvbuffer{number}.collectsourcevalues",
    "nvbuffer{number}.collecttimestamps",
    "nvbuffer{number}.fillcount",
    "nvbuffer{number}.fillmode",
    "nvbuffer{number}.measurefunctions",
    "nvbuffer{number}.measureranges",
    "nvbuffer{number}.n",
    "nvbuffer{number}.readings",
    "nvbuffer{number}.sourcefunctions",
    "nvbuffer{number}.sourceoutputstates",
    "nvbuffer{number}.sourceranges",
    "nvbuffer{number}.sourcevalues",
    "nvbuffer{number}.statuses",
    "nvbuffer{number}.timestampresolution",
    "nvbuffer{number}.timestamps",
    "opc()",
    "os.remove()",
    "os.rename()",
    "print()",
    "printbuffer()",
    "printnumber()",
    "reset()",
    "savebuffer()",
    "script.anonymous",
    "script.delete()",
    "script.factory.catalog()",
    "script.load()",
    "script.new()",
    "script.newautorun()",
    "script.restore()",
    "script.run()",
    "script.user.catalog()",
    "serial.FLOW_HARDWARE",
    "serial.FLOW_NONE",
    "serial.PARITY_EVEN",
    "serial.PARITY_NONE",
    "serial.PARITY_ODD",
    "serial.baud",
    "serial.databits",
    "serial.flowcontrol",
    "serial.parity",
    "serial.read()",
    "serial.write()",
    "settime()",
    "settimezone()",
    "setup.poweron",
    "setup.recall()",
    "setup.save()",
    "smu{smu_name}.ASYNC",
    "smu{smu_name}.AUTORANGE_FOLLOW_LIMIT",
    "smu{smu_name}.AUTORANGE_OFF",
    "smu{smu_name}.AUTORANGE_ON",
    "smu{smu_name}.AUTOZERO_AUTO",
    "smu{smu_name}.AUTOZERO_OFF",
    "smu{smu_name}.AUTOZERO_ONCE",
    "smu{smu_name}.CALSTATE_CALIBRATING",
    "smu{smu_name}.CALSTATE_LOCKED",
    "smu{smu_name}.CALSTATE_UNLOCKED",
    "smu{smu_name}.CAL_AUTO",
    "smu{smu_name}.CAL_NEGATIVE",
    "smu{smu_name}.CAL_POSITIVE",
    "smu{smu_name}.CONTACT_FAST",
    "smu{smu_name}.CONTACT_MEDIUM",
    "smu{smu_name}.CONTACT_SLOW",
    "smu{smu_name}.DELAY_AUTO",
    "smu{smu_name}.DELAY_OFF",
    "smu{smu_name}.DISABLE",
    "smu{smu_name}.ENABLE",
    "smu{smu_name}.FILL_ONCE",
    "smu{smu_name}.FILL_WINDOW",
    "smu{smu_name}.FILTER_MEDIAN",
    "smu{smu_name}.FILTER_MOVING_AVG",
    "smu{smu_name}.FILTER_OFF",
    "smu{smu_name}.FILTER_ON",
    "smu{smu_name}.FILTER_REPEAT_AVG",
    "smu{smu_name}.OE_NONE",
    "smu{smu_name}.OE_OUTPUT_OFF",
    "smu{smu_name}.OUTPUT_DCAMPS",
    "smu{smu_name}.OUTPUT_DCVOLTS",
    "smu{smu_name}.OUTPUT_HIGH_Z",
    "smu{smu_name}.OUTPUT_NORMAL",
    "smu{smu_name}.OUTPUT_OFF",
    "smu{smu_name}.OUTPUT_ON",
    "smu{smu_name}.OUTPUT_ZERO",
    "smu{smu_name}.REL_OFF",
    "smu{smu_name}.REL_ON",
    "smu{smu_name}.SENSE_CALA",
    "smu{smu_name}.SENSE_LOCAL",
    "smu{smu_name}.SENSE_REMOTE",
    "smu{smu_name}.SETTLE_DIRECT_IRANGE",
    "smu{smu_name}.SETTLE_FAST_ALL",
    "smu{smu_name}.SETTLE_FAST_POLARITY",
    "smu{smu_name}.SETTLE_FAST_RANGE",
    "smu{smu_name}.SETTLE_SMOOTH",
    "smu{smu_name}.SETTLE_SMOOTH_100NA",
    "smu{smu_name}.SOURCE_HOLD",
    "smu{smu_name}.SOURCE_IDLE",
    "smu{smu_name}.abort()",
    "smu{smu_name}.buffer.getstats()",
    "smu{smu_name}.buffer.recalculatestats()",
    "smu{smu_name}.cal.adjustdate",
    "smu{smu_name}.cal.date",
    "smu{smu_name}.cal.due",
    "smu{smu_name}.cal.lock()",
    "smu{smu_name}.cal.password",
    "smu{smu_name}.cal.polarity",
    "smu{smu_name}.cal.restore()",
    "smu{smu_name}.cal.save()",
    "smu{smu_name}.cal.state",
    "smu{smu_name}.cal.unlock()",
    "smu{smu_name}.contact.calibratehi()",
    "smu{smu_name}.contact.calibratelo()",
    "smu{smu_name}.contact.check()",
    "smu{smu_name}.contact.r()",
    "smu{smu_name}.contact.speed",
    "smu{smu_name}.contact.threshold",
    "smu{smu_name}.makebuffer()",
    "smu{smu_name}.measure{ivpr}andstep()",
    "smu{smu_name}.measure.{ivpr}()",
    "smu{smu_name}.measure.analogfilter",
    "smu{smu_name}.measure.autorange{iv}",
    "smu{smu_name}.measure.autozero",
    "smu{smu_name}.measure.calibrate{iv}()",
    "smu{smu_name}.measure.count",
    "smu{smu_name}.measure.delay",
    "smu{smu_name}.measure.delayfactor",
    "smu{smu_name}.measure.filter.count",
    "smu{smu_name}.measure.filter.enable",
    "smu{smu_name}.measure.filter.type",
    "smu{smu_name}.measure.highcrangedelayfactor",
    "smu{smu_name}.measure.interval",
    "smu{smu_name}.measure.lowrange{iv}",
    "smu{smu_name}.measure.nplc",
    "smu{smu_name}.measure.overlapped{ivpr}()",
    "smu{smu_name}.measure.range{iv}",
    "smu{smu_name}.measure.rel.enable{ivpr}",
    "smu{smu_name}.measure.rel.level{ivpr}",
    "smu{smu_name}.nvbuffer{number}",
    "smu{smu_name}.nvbuffer{number}.readings[N]",
    "smu{smu_name}.reset()",
    "smu{smu_name}.savebuffer()",
    "smu{smu_name}.sense",
    "smu{smu_name}.source.autorange{iv}",
    "smu{smu_name}.source.calibrate{iv}()",
    "smu{smu_name}.source.compliance",
    "smu{smu_name}.source.delay",
    "smu{smu_name}.source.func",
    "smu{smu_name}.source.highc",
    "smu{smu_name}.source.level{iv}",
    "smu{smu_name}.source.limit{iv}",
    "smu{smu_name}.source.lowrange{iv}",
    "smu{smu_name}.source.offfunc",
    "smu{smu_name}.source.offlimit{iv}",
    "smu{smu_name}.source.offmode",
    "smu{smu_name}.source.output",
    "smu{smu_name}.source.outputenableaction",
    "smu{smu_name}.source.range{iv}",
    "smu{smu_name}.source.settling",
    "smu{smu_name}.source.sink",
    "smu{smu_name}.trigger.ARMED_EVENT_ID",
    "smu{smu_name}.trigger.IDLE_EVENT_ID",
    "smu{smu_name}.trigger.MEASURE_COMPLETE_EVENT_ID",
    "smu{smu_name}.trigger.PULSE_COMPLETE_EVENT_ID",
    "smu{smu_name}.trigger.SOURCE_COMPLETE_EVENT_ID",
    "smu{smu_name}.trigger.SWEEPING_EVENT_ID",
    "smu{smu_name}.trigger.SWEEP_COMPLETE_EVENT_ID",
    "smu{smu_name}.trigger.arm.count",
    "smu{smu_name}.trigger.arm.set()",
    "smu{smu_name}.trigger.arm.stimulus",
    "smu{smu_name}.trigger.autoclear",
    "smu{smu_name}.trigger.count",
    "smu{smu_name}.trigger.endpulse.action",
    "smu{smu_name}.trigger.endpulse.set()",
    "smu{smu_name}.trigger.endpulse.stimulus",
    "smu{smu_name}.trigger.endsweep.action",
    "smu{smu_name}.trigger.initiate",
    "smu{smu_name}.trigger.measure.{ivpr}()",
    "smu{smu_name}.trigger.measure.action",
    "smu{smu_name}.trigger.measure.set()",
    "smu{smu_name}.trigger.measure.stimulus",
    "smu{smu_name}.trigger.source.action",
    "smu{smu_name}.trigger.source.limit{iv}",
    "smu{smu_name}.trigger.source.linear{iv}()",
    "smu{smu_name}.trigger.source.list{iv}()",
    "smu{smu_name}.trigger.source.log{iv}()",
    "smu{smu_name}.trigger.source.set()",
    "smu{smu_name}.trigger.source.stimulus",
    "status.condition",
    "status.measurement.{register}",
    "status.measurement.buffer_available.{register}",
    "status.measurement.current_limit.{register}",
    "status.measurement.instrument.{register}",
    "status.measurement.instrument.smu{smu_name}.{register}",
    "status.measurement.reading_overflow.{register}",
    "status.measurement.voltage_limit.{register}",
    "status.node_enable",
    "status.node_event",
    "status.operation.{register}",
    "status.operation.calibrating.{register}",
    "status.operation.instrument.digio.{register}",
    "status.operation.instrument.digio.trigger_overrun.{register}",
    "status.operation.instrument.lan.{register}",
    "status.operation.instrument.lan.trigger_overrun.{register}",
    "status.operation.instrument.smu{smu_name}.{register}",
    "status.operation.instrument.smu{smu_name}.trigger_overrrun.{register}",
    "status.operation.instrument.trigger_blender.{register}",
    "status.operation.instrument.trigger_blender.trigger_overrun.{register}",
    "status.operation.instrument.trigger_timer.{register}",
    "status.operation.instrument.trigger_timer.trigger_overrun.{register}",
    "status.operation.instrument.tsplink.{register}",
    "status.operation.instrument.tsplink.trigger_overrun.{register}",
    "status.operation.measuring.{register}",
    "status.operation.remote.{register}",
    "status.operation.sweeping.{register}",
    "status.operation.trigger_overrun.{register}",
    "status.operation.user.{register}",
    "status.questionable.{register}",
    "status.questionable.calibration.{register}",
    "status.questionable.instrument.{register}",
    "status.questionable.instrument.smu{smu_name}.{register}",
    "status.questionable.over_temperature.{register}",
    "status.questionable.unstable_output.{register}",
    "status.request_enable",
    "status.request_event",
    "status.reset()",
    "status.standard.{register}",
    "status.system.{register}",
    "status.system2.{register}",
    "status.system3.{register}",
    "status.system4.{register}",
    "status.system5.{register}",
    "timer.measure.t()",
    "timer.reset()",
    "trigger.EVENT_ID",
    "trigger.blender.clear()",
    "trigger.blender.reset()",
    "trigger.blender.wait()",
    "trigger.blender[N].EVENT_ID",
    "trigger.blender[N].orenable",
    "trigger.blender[N].overrun",
    "trigger.blender[N].stimulus[N]",
    "trigger.clear()",
    "trigger.timer[N].EVENT_ID",
    "trigger.timer[N].clear()",
    "trigger.timer[N].count",
    "trigger.timer[N].delay",
    "trigger.timer[N].delaylist",
    "trigger.timer[N].overrun",
    "trigger.timer[N].passthrough",
    "trigger.timer[N].reset()",
    "trigger.timer[N].stimulus",
    "trigger.timer[N].wait()",
    "trigger.wait()",
    "tsplink.group",
    "tsplink.master",
    "tsplink.readbit()",
    "tsplink.readport()",
    "tsplink.reset()",
    "tsplink.state",
    "tsplink.trigger[N].EVENT_ID",
    "tsplink.trigger[N].assert()",
    "tsplink.trigger[N].clear()",
    "tsplink.trigger[N].mode",
    "tsplink.trigger[N].overrun",
    "tsplink.trigger[N].pulsewidth",
    "tsplink.trigger[N].release()",
    "tsplink.trigger[N].reset()",
    "tsplink.trigger[N].stimulus",
    "tsplink.trigger[N].wait()",
    "tsplink.writebit()",
    "tsplink.writeport()",
    "tsplink.writeprotect()",
    "tspnet.clear()",
    "tspnet.connect()",
    "tspnet.disconnect()",
    "tspnet.execute()",
    "tspnet.idn()",
    "tspnet.read()",
    "tspnet.readavailable()",
    "tspnet.reset()",
    "tspnet.termination()",
    "tspnet.timeout",
    "tspnet.tsp.abort()",
    "tspnet.tsp.abortonconnect",
    "tspnet.tsp.rbtablecopy()",
    "tspnet.tsp.runscript()",
    "tspnet.write()",
    "userstring.add()",
    "userstring.catalog()",
    "userstring.delete()",
    "userstring.get()",
    "waitcomplete()",
)

PROPERTY_LISTS = (
    "trigger.blender[1].stimulus",
    "trigger.blender[2].stimulus",
    "smua.nvbuffer1.readings",
    "smua.nvbuffer2.readings",
    "smub.nvbuffer1.readings",
    "smub.nvbuffer2.readings",
    "readings",
)

_PLACEHOLDERS = {
    "register": ["condition", "enable", "event", "ntr", "ptr"],
    "number": ["1", "2"],
    "smu_name": ["a", "b"],
    "iv": ["v", "i"],
    "ivpr": ["v", "i", "r", "p"],
}

ALL_CMDS = set()

# replace our placeholders
for cmd in _ALL_CMDS_WITH_PLACEHOLDERS:

    # find all placeholders in given command
    placeholders = [p for p in _PLACEHOLDERS if "{%s}" % p in cmd]

    if len(placeholders) > 0:

        # get placeholder values
        values = [_PLACEHOLDERS[p] for p in placeholders]

        # generate commands with replaced placeholders
        new_cmds = set()

        for value_tuple in itertools.product(*values):
            new_cmds.add(
                cmd.format(**{p: v for p, v in zip(placeholders, value_tuple)})
            )

        # add new commands
        ALL_CMDS.update(new_cmds)
    else:
        ALL_CMDS.add(cmd)


last_commands = [c.split(".")[-1] for c in ALL_CMDS]

CONSTANTS = set(cmd for cmd in last_commands if cmd.isupper())
FUNCTIONS = set(cmd.replace("()", "") for cmd in last_commands if cmd.endswith("()"))

# strip syntax elements
ALL_CMDS = set(cmd.replace("()", "") for cmd in ALL_CMDS)
